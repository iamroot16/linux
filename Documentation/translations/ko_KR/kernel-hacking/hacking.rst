.. _kernel_hacking_hack:

:원본: Documentation/kernel-hacking/hacking.rst

============================================
Unreliable Guide To Hacking The Linux Kernel
============================================

:저자: Rusty Russell
:역자: 김남형 <pastime@ece.uos.ac.kr>

소개
====

Rusty 의 Unreliable Guide to Linux Kernel Hacking 문서를
읽고 있는 여러분을 환영한다. 이 문서는 커널 코드에서 사용되는
공통적인 루틴들과 일반적인 요구사항들을 설명하고 있다:
이 문서의 목적은 숙련된 C 프로그래머들에게 리눅스 커널 개발에
대한 입문서로서 사용되고자 하는 것이다. 이 문서에서는 구체적인
구현에 관한 부분은 다루지 않는다.

이 문서를 읽기 전에, 한가지 사실을 이해해 주기 바란다. 사실
개인적으로 나는 전체적으로 만족스럽지 못한 수준의 이 문서를
작성하고 싶지 않았었다. 하지만 항상 이러한 문서를 읽고는 싶었기
때문에 어쩔수 없이? 이렇게 작성하게 되었다. 이 문서가 훌륭한
요약서 혹은 커널에 대한 일반적인 시작점이나 임의의 정보를
제공할 수 있는 좋은 문서로 발전해 가기를 바란다.

동작 모드 (the Players)
============================

특정한 순간에 시스템 상의 CPU 는 다음과 같은 상태 중의 하나가 된다:

-  특정 프로세스에 연관되지 않은, 하드웨어 인터럽트 처리;

-  특정 프로세스에 연관되지 않은, 소프트웨어 인터럽트 (softirq, tasklet) 처리;

-  특정 프로세스에 연관되어 커널 모드에서 동작(user context);

-  사용자 모드에서 특정 프로세스 수행.

위의 항목들 사이에는 우선순위를 가진다: 
아래의 둘은 서로를 선점할 수 있지만, 위의 둘은 엄격한 계층을 갖는다:
각각은 오직 그것보다 위에 있는 것에 의해서 선점 될 수 있다.
마지막의 상태 (사용자 모드) 를 제외한 다른 상태들은 오직 자신보다 
상위에 있는 상태에 의해 선점될 수 있다. 예를 들어, softirq 가 CPU 에서 
수행되고 있는 동안 다른 softirq 는 이를 선점할 수 없지만 하드웨어 인터럽트가 
발생하면 선점된다. 하지만 시스템내의 다른 CPU 들은 독립적으로 수행된다.

앞으로 user context [1]_ 에서 실제적인 비선점성을 가지기 위해 인터럽트를 
막아두는 방법들을 살펴볼 것이다.

User Context
------------

user context 는 시스템 콜이나 다른 트랩 등에 의해서 진입한 코드를 말한다: 
사용자 모드 처럼, 더 중요한 태스크나 인터럽트에 의해서 선점될 수 있다.
:c:func:`schedule()` 함수를 호출하는 것으로 sleep 을 할 수 있다.

.. note::

    모듈을 로딩하거나 언로딩할 때, 그리고 블록 디바이스 드라이버에 대한 
    연산을 수행하는 경우에는 항상 user context 에 있는 것이다.

user context 상에서는 (현재 수행중인 태스크를 가리키는) ``current`` 포인터를 
이용할 수 있고, :c:func:`in_interrupt()`매크로 (``include/linux/preempt.h``)
는 거짓을 리턴한다.

.. warning::

    선점 혹은 softirq가 비활성화 되어있는 경우에도 (아래를 보자),
    :c:func:`in_interrupt()` 매크로가 무조건 거짓을 리턴한다는 것을 염두에 두자.

하드웨어 인터럽트 (Hard IRQs)
------------------------------

타이머 틱, 네트워크 카드, 키보드와 같은 것들은 어떤 순간에도 인터럽트를 
발생시킬 수 있는 실제 하드웨어 들이다. 
커널에서는 인터럽트 핸들러를 수행해서 이러한 하드웨어들에 대한 처리를 한다. 
커널에서는 이러한 인터럽트 핸들러가 절대 재진입되지 않도록 해 준다: 
만약 (처리 중에) 같은 인터럽트가 발생되었다면, 그것은 큐에 들어가게 된다 
(큐가 가득 차있는 경우 버려진다). 
이렇게 인터럽트를 비활성화 해 두기 때문에, 
인터럽트 핸들러는 매우 빨리 수행되어야 한다: 
주로 인터럽트 핸들러에서는 인터럽트를 받았다는 응답을 보내주고, 실행은 
'소프트웨어 인터럽트' 를 이용해 처리하도록 표시한 후 종료한다.

하드웨어 인터럽트 부분을 처리하는 부분에서는 in_irq() 매크로가 참을 리턴한다.

.. warning::

    인터럽트가 비활성화 되어있는 경우에는 in_irq() 매크로가 
    무조건 거짓을 리턴한다는 것을 염두에 두자 (아래를 보자).

소프트웨어 인터럽트 컨택스트: Softirqs, Tasklets
----------------------------------------------------------

시스템 콜을 호출한 뒤 사용자 모드로 돌아가기 전이나 하드웨어 인터럽트 핸들러가 
종료한 후에는 (보통 하드웨어 인터럽트 핸들러에서 처리한) 표시된 
'소프트웨어 인터럽트' 가 수행된다. (``kernel/softirq.c``).

많은 실제적인 인터럽트 처리가 이 부분에서 이루어진다. 
SMP 초창기에는 오직 bottom halves (하반부, BHs) 라는 개념만이 존재하였는데, 
이것은 다수의 CPU 에 의한 장점을 살리지 못했다. 
얼마 후 (고성능의 컴퓨터로 전환한 후에?) 이러한 제한사항들은 사라졌고 
softirq로 전환했다.

``include/linux/interrupt.h`` 파일에 여러가지 softirq 리스트가 있다. 
매우 중요한 softirq는 타이머 softirq 이다. (``include/linux/timer.h``): 
여기서는 주어진 길이만큼의 시간이 지난 후에 특정 함수를 
호출하도록 등록할 수 있다.

같은 softirq는 동시에 하나 이상의 cpu에서 동작할 것이기 때문에 
softirq는 종종 다루기 어렵다. 이러한 이유로, 
tasklet (``include/linux/interrupt.h``) 은 더 자주 사용된다: 
그것들은 동적으로 등록할 수 있다는 점 (즉, 원하는 만큼 많이 등록할 수 있다) 
그리고 각각의 tasklet 은 동시에 수행될 수 있지만, 
특정 tasklet 은 한 순간에 오직 하나의 CPU 에서만 수행되도록 보장한다. [2]_

.. warning::

    'tasklet' 이라는 이름은 잘못된 것이다: 이것은 task 와 아무런 연관이 없다. 
    (아마 이때 Alexey Kuznetsov 가 보드카를 많이 마신 것 같다..)

현재 softirq (혹은 하반부나 tasklet) 가 실행 중인지를 알아보기 위해 
:c:func:`in_softirq()` 매크로 (``include/linux/preempt.h``)를 사용할 수 있다.

.. warning::

    :ref:`botton half lock <local_bh_disable>` 락이 걸려있는 경우에는 
    이 매크로가 항상 거짓을 리턴함을 염두에 두자.
    
역자주
-------

.. [1] 프로세스가 커널 모드에서 동작하고 있는 상태를 말하는 것이다. 이 글을 읽는 독자들이 커널영역에서 프로그래밍을 하기 때문에 이렇게 부르는 것 같다._
.. [2] 하나의 tasklet 이 여러 CPU 에서 중복되어 실행되지 않는 것을 보장한다._
